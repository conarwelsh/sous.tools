import { GoogleGenerativeAI } from "@google/generative-ai";
import { execSync } from "child_process";
import fs from "fs";
import path from "path";

async function main() {
  const apiKey = process.env.GEMINI_API_KEY;
  const githubToken = process.env.GITHUB_TOKEN;
  const commentBody = process.env.COMMENT_BODY;
  const issueNumber = process.env.ISSUE_NUMBER;
  const repoFull = process.env.GITHUB_REPOSITORY; // "owner/repo"
  const issueTitle = process.env.ISSUE_TITLE || "Issue Action";
  
  if (!apiKey || !githubToken || !commentBody || !repoFull) {
    console.error("Missing required environment variables.");
    process.exit(1);
  }

  const prompt = commentBody.replace("@gemini", "").trim();
  console.log(`Processing prompt: ${prompt}`);

  const genAI = new GoogleGenerativeAI(apiKey);
  // Using 1.5 Flash for speed and large context
  const model = genAI.getGenerativeModel({ model: "gemini-1.5-flash" });

  // Gather some context: File list
  const fileList = execSync("find . -maxdepth 3 -not -path '*/.*'").toString();

  const systemPrompt = `
    You are Gemini, an expert autonomous software engineer.
    You are running in a GitHub Action. You have access to the repository filesystem.
    
    Current File Structure (limited depth):
    ${fileList}

    User Request: "${prompt}"
    Issue Context: #${issueNumber} - ${issueTitle}

    Your goal is to fulfill the user's request.
    If the user wants a fix or feature:
    1. Identify relevant files.
    2. Suggest specific changes.
    3. Generate a branch name.
    
    If the user wants research:
    1. Search the codebase (you can suggest commands to run, but here you should just reason about it).
    2. Provide a detailed report.

    Output STRICT JSON:
    {
      "action": "fix" | "research",
      "thought": "Your reasoning...",
      "branchName": "gemini/action-...",
      "filesToModify": [
        { "path": "string", "content": "FULL new content of the file" }
      ],
      "report": "Markdown response for the user",
      "prTitle": "short title",
      "prBody": "detailed description"
    }
  `;

  try {
    const result = await model.generateContent(systemPrompt);
    const response = await result.response;
    const text = response.text();
    const jsonStr = text.replace(/```json/g, "").replace(/```/g, "").trim();
    const data = JSON.parse(jsonStr);

    console.log(`Action: ${data.action}`);
    console.log(`Thought: ${data.thought}`);

    if (data.action === "fix" && data.filesToModify && data.filesToModify.length > 0) {
        const branch = data.branchName || `gemini/fix-${issueNumber}-${Date.now()}`;
        
        console.log(`Creating branch ${branch}...`);
        execSync(`git checkout -b ${branch}`);
        
        for (const file of data.filesToModify) {
            console.log(`Modifying ${file.path}...`);
            const dir = path.dirname(file.path);
            if (!fs.existsSync(dir)) {
                fs.mkdirSync(dir, { recursive: true });
            }
            fs.writeFileSync(file.path, file.content);
            execSync(`git add "${file.path}"`);
        }

        execSync(`git commit -m "${data.prTitle || `fix: Gemini action for #${issueNumber}`}"`);
        execSync(`git push origin ${branch}`);

        // Create PR
        const prPayload = {
            title: data.prTitle || `fix: Gemini Agent for #${issueNumber}`,
            body: `${data.prBody || "Automated fix generated by Gemini."}\n\nCloses #${issueNumber}`,
            head: branch,
            base: "development" // Our standard dev branch
        };

        const prRes = await fetch(`https://api.github.com/repos/${repoFull}/pulls`, {
            method: "POST",
            headers: {
                Authorization: `Bearer ${githubToken}`,
                "Content-Type": "application/json",
                "User-Agent": "Gemini-Agent"
            },
            body: JSON.stringify(prPayload)
        });

        const prData = await prRes.json() as any;
        const prUrl = prData.html_url || "PR created";

        // Reply to issue
        await postComment(repoFull, issueNumber!, githubToken, `üöÄ **I have applied the fix!**\n\n${data.thought}\n\nView PR: ${prUrl}`);

    } else {
        // Just reply/report
        await postComment(repoFull, issueNumber!, githubToken, `üìã **Gemini Report:**\n\n${data.report || data.thought}`);
    }

  } catch (error) {
    console.error("Error:", error);
    await postComment(repoFull, issueNumber!, githubToken, `‚ùå **Error encountered during action:**\n\n\`\`\`\n${error}\n\`\`\``);
    process.exit(1);
  }
}

async function postComment(repo: string, issue: string, token: string, body: string) {
    await fetch(`https://api.github.com/repos/${repo}/issues/${issue}/comments`, {
        method: "POST",
        headers: {
            Authorization: `Bearer ${token}`,
            "Content-Type": "application/json",
            "User-Agent": "Gemini-Agent"
        },
        body: JSON.stringify({ body })
    });
}

main();
