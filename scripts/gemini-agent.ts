import { GoogleGenerativeAI } from "@google/generative-ai";
import { execSync } from "child_process";

async function main() {
  const apiKey = process.env.GEMINI_API_KEY;
  const githubToken = process.env.GITHUB_TOKEN;
  const commentBody = process.env.COMMENT_BODY;
  const issueNumber = process.env.ISSUE_NUMBER;
  const repoFull = process.env.GITHUB_REPOSITORY; // "owner/repo"
  
  if (!apiKey || !githubToken || !commentBody) {
    console.error("Missing required environment variables.");
    process.exit(1);
  }

  // Only process if addressed to @gemini
  if (!commentBody.includes("@gemini")) {
    console.log("Not addressed to Gemini.");
    return;
  }

  const genAI = new GoogleGenerativeAI(apiKey);
  const model = genAI.getGenerativeModel({ model: "gemini-pro" });

  const prompt = `
    You are an expert autonomous software engineer named Gemini.
    You have been invoked in a GitHub comment.
    
    Comment: "${commentBody}"
    
    If the user is asking for a code change (e.g. "/fix", "please fix", "implement this"), 
    you should generate a git branch name and a set of instructions for what to change.
    
    Since you are running in a CI environment without full repo context access in this prompt, 
    you must decide if you can perform the action.
    
    For this MVP, if the command is "/fix" or implies a fix, assume you would generate a branch named 'gemini/fix-{issueNumber}-{timestamp}'.
    
    Output STRICT JSON:
    {
      "action": "fix" | "reply",
      "branchName": "string (if fix)",
      "reply": "Markdown response to the user"
    }
  `;

  try {
    const result = await model.generateContent(prompt);
    const text = result.response.text();
    const jsonStr = text.replace(/```json/g, "").replace(/```/g, "").trim();
    const data = JSON.parse(jsonStr);

    if (data.action === "fix") {
        const branch = data.branchName || `gemini/fix-${issueNumber}-${Date.now()}`;
        
        // In a real scenario, the Agent would actually MODIFY code here based on the request.
        // For this MVP, we will just create the branch and push a dummy change or just the branch itself.
        // To truly "fix" it, we'd need to pass file contents to the LLM and get back diffs.
        
        console.log(`Creating branch ${branch}...`);
        execSync(`git checkout -b ${branch}`);
        
        // Simulate a fix
        execSync(`echo "// Gemini fix for issue #${issueNumber}" >> GEMINI_FIX_LOG.md`);
        execSync(`git add GEMINI_FIX_LOG.md`);
        execSync(`git commit -m "feat: Gemini agent fix for #${issueNumber}"`);
        execSync(`git push origin ${branch}`);

        // Create PR
        const prBody = JSON.stringify({
            title: `fix: Gemini Agent for #${issueNumber}`,
            body: `Automated fix generated by Gemini Agent.

${data.reply}`,
            head: branch,
            base: "staging"
        });

        await fetch(`https://api.github.com/repos/${repoFull}/pulls`, {
            method: "POST",
            headers: {
                Authorization: `Bearer ${githubToken}`,
                "Content-Type": "application/json",
                "User-Agent": "Gemini-Agent"
            },
            body: prBody
        });

        // Reply to issue confirming PR
        await postComment(repoFull, issueNumber!, githubToken, `ðŸš€ I have created a PR with the requested changes: (PR link will appear here once created).`);

    } else {
        // Just reply
        await postComment(repoFull, issueNumber!, githubToken, data.reply);
    }

  } catch (error) {
    console.error("Error:", error);
    process.exit(1);
  }
}

async function postComment(repo: string, issue: string, token: string, body: string) {
    await fetch(`https://api.github.com/repos/${repo}/issues/${issue}/comments`, {
        method: "POST",
        headers: {
            Authorization: `Bearer ${token}`,
            "Content-Type": "application/json",
            "User-Agent": "Gemini-Agent"
        },
        body: JSON.stringify({ body })
    });
}

main();
